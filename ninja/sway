#!/usr/bin/python
from __future__ import division,print_function
import sys,re,random,argparse,traceback,time
sys.dont_write_bytecode=True

###############################################################################
# Copyright (c) 2016 tim@menzies.us
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
###############################################################################

### GLOBALS ###################################################################
PASS=FAIL=0

help = lambda : [
"""
(C) 2016, tim@menzies.us MIT, v2
Useful routines for building simple data miners and optimizers
""","""
"And He shall have sway and dominion over all the world." 
-- Wolf (a.k.a. Eddie Izzard) 

Implements incremental sway (O(N), not O(3N)).

For simplicity's sake, there is no normalization on objectives.  Hence, the eval
functions need to be well-behaved i.e. ideally 0..1 or, more realistically, (a)
all goals are to be minimized; (b) the eval function does not deliver numbers
that are orders of magnitude different.
""",
  elp("-C", "SWAY's target population = pop^swayCull", swayCull  = 0.5),
  elp("-S", "SWAY's smallest size, leaf clusters",     swayStop  = 20),
  elp("-b", "SWAY projections bigger",                 swayBigger= 0.01),
  elp("-K", "kind of model class",                     kind      = ["Row", "Model"]),
  elp("-N", "Enable distance normalization",           normalize = False),
  elp("-X", "run unit tests",                          tests     = False),
  elp("-c", "continous domination bigger",             cdomBigger= 0.01),
  elp("-n", "keep at most, say, 256 samples",          samples   = [256,128,512,1024]),
  elp("-r", "in pretty print, round numbers",          round     = 3),
  elp("-R", "probability of reading a row",            some      = 1.00),
  elp("-s", "random number seed",                      seed      = 61409389),
  elp("-t", "training data (arff format",              train     = "train.csv"),
  elp("-T", "testing data (csv format). If null, do xval on train data.",
                                                       test      = "test.csv")]
def elp(flag,h, **d):
  def elp1():
    if val is False        : return dict(help=h, action="store_true")
    if isinstance(val,list): return dict(help=h, choices=val,          default=default, metavar=m ,type=t)
    else                   : return dict(help=h + ("; e.g. %s" % val), default=default, metavar=m, type=t)
  key,val = d.items()[0]
  default = val[0] if isinstance(val,list) else val
  m,t = "S",str
  if isinstance(default,int)  : m,t= "I",int
  if isinstance(default,float): m,t= "F",float
  return flag,"--" + key, elp1()

def options(before, after, *lst):
  parser = argparse.ArgumentParser(epilog=after, description = before,
              formatter_class = argparse.RawDescriptionHelpFormatter)
  for flag, key, rest in lst:
    parser.add_argument(flag, key,**rest)
  return parser.parse_args()

THE = options(*help())

### LIB ########################################################################

def same(x)  : return x
def less(x,y): return x < y
def more(x,y): return x > y
def max(x,y) : return x if x>y else y
def min(x,y) :  return x if x<y else y
def any(lst) :  return random.choose(list)
def rseed(s) :  random.seed(s or THE.seed)
def r():  return random.random()
def isa(x,y): return isinstance(x,y)

def oks():
  global PASS, FAIL
  if THE.tests:
    print("\n# PASS= %s FAIL= %s %%PASS = %s%%"  % (
          PASS, FAIL, int(round(PASS*100/(PASS+FAIL+0.001)))))

def ok(f):
  global PASS, FAIL
  if THE.tests:
    try:
      print("\n-----| %s |-----------------------" % f.__name__)
      if f.__doc__:
        print("# "+ re.sub(r'\n[ \t]*',"\n# ",f.__doc__))
      f()
      print("# pass")
      PASS += 1
    except Exception,e:
      FAIL += 1
      print(traceback.format_exc()) 
  return f


def atom(x)  :
  try: return float(x),Num
  except ValueError: return x,Sym


def kv(d, private="_"):
  "Print dicts, keys sorted (ignoring 'private' keys)"
  def _private(key):
    return key[0] == private
  def pretty(x):
    return round(x,THE.round) if isa(x,float) else x
  return '('+', '.join(['%s: %s' % (k,pretty(d[k]))
          for k in sorted(d.keys())
          if not _private(k)]) + ')'


def timeit(f,repeats=1):
  start = time.time()
  for _ in xrange(repeats):
    f()
  stop = time.time()
  return (stop - start)/repeats


class Magic(object):
  def __repr__(i):
    return i.__class__.__name__ + kv(i.__dict__)


### Columns  ###################################################################
class Sample(Magic):
  def __init__(i, init=[],max=None):
    i.n, i._some  = 0, []
    i.max = max or THE.samples 
    map(i.add,init)
  def add(i,x):
    i.n += 1
    now  = len(i._some)
    if now < i.max:
      i._some += [x]
    elif r() <= now/i.n:
      i._some[ int(r() * now) ]= x

class Summary(Magic):
  def __init__(i,init=[]):
    i.reset()
    map(i.add,init)

class Thing(Summary):
  "some thing that can handle  Nums or Syms"
  UNKNOWN = "?"
  def __init__(i,pos,txt):
    i.txt, i.pos, i.details, i.samples = txt, pos, None, Sample()
  def add(i,x):
    if x != Thing.UNKNOWN:
      if i.details is None:
        x,what  = atom(x)
        i.details = what()
      x = i.details.add(x)
      i.samples.add(x)
    return x

class Num(Summary):
  def reset(i):
    i.mu,i.n,i.m2,i.up,i.lo = 0,0,0,-10e32,10e32
  def add(i,x):
    i.n += 1
    x = float(x)
    if x > i.up: i.up=x
    if x < i.lo: i.lo=x
    delta = x - i.mu
    i.mu += delta/i.n
    i.m2 += delta*(x - i.mu)
    return x 
  def sub(i,x):
    i.n   = max(0,i.n - 1)
    delta = x - i.mu
    i.mu  = max(0,i.mu - delta/i.n)
    i.m2  = max(0,i.m2 - delta*(x - i.mu))
  def sd(i):
    return 0 if i.n <= 2 else (i.m2/(i.n - 1))**0.5
  def norm(i,x):
    if THE.normalize:
      tmp= (x - i.lo) / (i.hi - i.lo + 10**-32)
      return min(1, max(0,tmp))
    return x
  def dist(i,x,y):
    return i.norm(x) - i.norm(y)
  def furthest(i,x) :
    return i.up if x <(i.up-i.lo)/2 else i.lo

class Sym(Summary):
  def reset(i):
     i.counts, i.most, i.mode, i.n = {},0,None,0
  def add(i,x):
    i.n += 1
    new = i.counts[x] = i.counts.get(x,0) + 1
    if new > i.most:
      i.most, i.mode = new,x
    return x
  def sub(i,x):
    i.n -= 1
    i.counts[x] -= 1
    if x == i.mode:
      i.most, i.mode = None,None
  def norm(i,x)   : return x
  def dist(i,x,y) : return 0 if x==y else 1
  def furthest(i,x): return "SoMEcrazyTHing"
  def k(i):
    return len(i.counts.keys())
  def ent(i):
    """Measures how many symbols are mixed up together.  If only one symbol, then
       ent=0 (nothing mixed up)."""
    tmp = 0
    for val in i.counts.values():
      p = val/i.n
      if p:
        tmp -= p*math.log(p,2)
    return tmp


### Rows  ######################################################################
class Row(Magic):
  rid = 0
  def __init__(i,lst):
    i.contents=lst
    i.rid = Row.rid = Row.rid+1
  def __repr__(i)       : return '#%s,%s' % (i.rid,i.contents)
  def __getitem__(i,k)  : return i.contents[k]
  def __setitem__(i,k,v): i.contents[k] = v

class Model(Row):
  def __init__(i,lst):
    super(Model, i).__init__(lst)
    i.labelled=False
  def ok(i):
    return True
  def label(i,tbl,cost=1):
    """Row labels are cached back into the row. So labelling
        N times only incur a single labelling cost."""
    if not i.labelled:
      i.label1()
      tbl.cost += cost
      for col in tbl.dep:
        col.add( i[col.pos] ) # and remember the new values
      i.labelled = True
    return i
  def label1(i):
    "Rewritten by subclass"
    return i
      

### Tables #####################################################################      
class Table(Magic):
  KIND  = {'Row':Row, 'Model':Model }[THE.kind]
  MORE  = ">"
  LESS  = "<"
  KLASS = "="
  SYM   = "!" 
  SKIP  = "-"
  def __init__(i):
    i._rows = []
    i.cost = 0
    i.cols,  i.objs, i.decs = [], [], []
    i.klass, i.gets, i.dep  = [], [], []
  def row0(i):
    return [col.txt for cols in i.cols]
  def __call__(i,row):
    if i.cols:
      row     = [i.cols[put].add(row[get])
                 for put,get in enumerate(i.gets)]
      i._rows += [ Table.KIND(row) ]
    else:
      for get,cell in enumerate(row):
        if cell[-1] != Table.SKIP:
          i.gets += [get]
          col     = Thing(len(i.cols) , cell)
          i.cols += [col]
          if   cell[0] == Table.MORE  : i.objs  += [(col,more)]
          elif cell[0] == Table.LESS  : i.objs  += [(col,less)]
          elif cell[0] == Table.KLASS : i.klass += [col]
          else                        : i.decs  += [col]
          #---------------------------------------
          for col,_ in i.objs  : i.dep   += [col]
          for col   in i.klass : i.dep   += [col]
          if cell[-1] == Table.SYM:
            col.details = Sym()              
  def distance(i,r1,r2,cols=None,f=2):
    cols = cols or i.decs
    inc,n = 0, 10**-32
    for col in cols:
      n    += 1
      x, y  = r1[col.pos], r2[col.pos]
      inc  += col.details.dist(x,y)**f
    return inc**f/n**f
  def label1(data,row):
    return row # usually rewritten by subclass


### Table filters #################################################################     
def csv2table(file, some=1):
  tbl= Table()
  with open(file) as fs:
    for line in fs:
      if r() <= THE.some:
        line = re.sub(r'([\n\r]|#.*)', "", line)
        row = map(lambda z:z.strip(), line.split(","))
        if len(row)> 1:
          tbl(row)
  return tbl

def arff2table(file): 
  tbl   = Table()
  seen  = lambda x,y: re.match('^[ \t]*'+x,y,re.IGNORECASE)
  data,div  = False," "
  words = []
  with open(file) as fs:
    for line in fs:
      line = re.sub(r'([\n\r]|#.*)', "", line)
      row  = map(lambda z:z.strip(), line.split(div))
      if row != []:
        if   seen("@relation", row[0]) : tbl.relation = row[1]
        if   seen("@attribute", row[0]): words += [row[1]]
        elif data and len(row) > 1     : tbl(row)
        elif seen("@data", row[0])     :
          data,div=True,","
          words[-1] = "=" + words[-1]
          tbl(words)
  return tbl

def table2arff(tbl):
  rel = tbl.relation if "relation" in tbl.__dict__ else "data"
  print("@relation", rel, "\n")
  for col in tbl.cols:
    vals="real"
    if isa(col.details,Sym):
      vals = set([row[col.pos] for row in tbl._rows
                if row[col.pos] != Thing.UNKNOWN])
      vals = '{' + ', '.join(vals) + '}'
    print("@attribute",col.txt,vals)
  print("\n@data")
  for row in tbl._rows:
    print(', '.join(map(str,row)))
      

### Optimizers #################################################################        
def bdom(x, y, tbl):
  x= label(tbl, x)
  y= label(tbl, y)
  betters = 0
  for col,better in tbl.objs:
    x1,y1 = x[col.pos], y[col.pos]
    if better(x1,y1) : betters += 1
    elif x1 != y1    : return False # must be worse, go quit
  return betters > 0

def cdom(x, y, tbl, ee= 2.718281828459):
  x= label(tbl, x)
  y= label(tbl, y)
  def w(better):
    return -1 if better == less else 1
  def expLoss(w,x1,y1,n):
    return -1*ee**( w*(x1 - y1) / n )
  def loss(x, y):
    losses= []
    n = min(len(x),len(y))
    for col,better in tbl.objs:
      x1 = x[col.pos] 
      y1 = y[col.pos] 
      loss += exploss( w(better),x1,y1,n)
    return sum(losses) / n
  l1= loss(x,y)
  l2= loss(y,x)
  return l1 < l2 if abs(l1 - l2)/l1 >= THE.cdomBigger else False

def sway( population, tbl, better= bdom) :
  def cluster(items, out):
    if len(items) < max(len(population)**THE.swayCull, THE.swayStop):
      out.append(items) 
    else:
      west, east, left, right = split(items, int(len(items)/2)) 
    if not better(east,west,tbl): cluster( left, out )
    if not better(west,east,tbl): cluster( right, out )  
    return out
  
  def split(items, mid,west=None, east=None):
    cosine = lambda a,b,c: ( a*a + c*c - b*b )/( 2*c+ 0.0001 )
    west   = west or any(items)
    east   = east or any(items)
    while east.rid  == west.rid:
      east = any(items)
    c      = tbl.distance(west, east)
    cBigger= c*(1 + THE.swayBigger)
    xs     = {}
    for n,item in enumerate(items):
       a = tbl.distance(item, west)
       b = tbl.distance(item, east)
       x = xs[ item.rid ] = cosine(a,b,c) # cosine rule
       if a > cBigger:
         redo += n
         return split(items, mid, item, east)
       if b > cBigger:
         redo += n
         return split(items, mid, west, item)   
    redo  = 0
    items = sorted(items, key= lambda item: xs[ item.rid ]) # sorted by 'x'
    return west, east, items[:mid], items[mid:] 
  # --------
  return cluster(population, []),redo


### Tests #################################################################        

@ok
def _ok1():
  "Can at least one test fail?"
  assert 1==2, "equality failure"

@ok
def _ok2():
  "Can at least one test pass?"
  assert 1==1, "equality failure"

@ok
def _atom():
  x,t=atom('23.1')
  assert isinstance(x,float), "coercion failure1"
  x,t= atom('tim menzies')
  assert isinstance(x,str), "coercion failure2"

@ok
def _sample():
  rseed(1)
  s = Sample(list('i have gone to seek a great perhaps'),max=8)
  print(s)
  assert s._some == [' ', ' ', 'n', 'p', 'v', 'e', 'r', 'p']

@ok
def _sym():
 assert Sym(list('i have gone to seek a great perhaps')).counts['a'] == 4

@ok
def _col():
  rseed(1)
  n= Num( [ 600 , 470 , 170 , 430 , 300])
  assert 164.711 <= n.sd() <= 164.712
  assert n.lo == 170
  assert n.up == 600

@ok
def _table(file= "data/weather.csv",show=True): 
  tbl= csv2table(file)
  for col in tbl.cols:
    print(col.pos,col)
  print("===")
  for col,what in tbl.objs:
    print(col.txt,what.__name__)
  if show:
    table2arff(tbl)

@ok
def _arff(file= "data/weather.arff",show=True):
  tbl= arff2table(file)
  for col in tbl.cols:
    print(col.pos,col)
  print("===")
  for col in tbl.klass:
    print(col)
  if show:
    table2arff(tbl)
          
@ok
def _table1():
  _table("data/diabetes.csv",show=False)

@ok
def _table2():
  print("Loading 100,000 records takes",
        timeit(lambda:
               _table("data/diabetes100000.csv",False)),"seconds.")

oks()
